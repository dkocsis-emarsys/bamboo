<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Bamboo</title>

  <link rel="apple-touch-icon" sizes="180x180" href="./site/resources/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./site/resources/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./site/resources/favicon-16x16.png">
  <link rel="manifest" href="./site/resources/site.webmanifest">

  <link href="https://fonts.googleapis.com/css?family=Noto+Sans:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/themes/prism-okaidia.min.css">
  <link rel="stylesheet" href="./site/style.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
</head>
<body>
  <div class="s-header">
    <img class="s-header__logo" src="./site/resources/logo.svg">
    <a class="s-header__link" href="https://github.com/dkocsis-emarsys/bamboo"><div class="s-header__link-text">View on GitHub</div><svg version="1.1" width="16" height="16" viewBox="0 0 16 16" class="octicon octicon-mark-github" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a>
  </div>

  <div class="s-container">
    <div class="s-content">
      <h1>What is Bamboo?</h1>

      <p>Bamboo is a simple extension of the base HTMLElement class. It helps developers to easily create feature rich web components.</p>

      <p>Features:</p>

      <ul>
        <li>Unified attribute and property handling</li>
        <li>State value transforming</li>
        <li>Auto-bind property to state</li>
        <li>Communication between parent and child components</li>
        <li>Lighterhtml based templating with multi-template system</li>
        <li>Local and global state management</li>
        <li>Extra callbacks to never miss a moment</li>
        <li>And much more...</li>
      </ul>

      <blockquote class="s-docs__info">
        <h4 style="margin:0 0 24px;">What's with the name?</h4>
        Since bamboo is the <b>perfect combination of strength and flexibility</b>, it has come to represent <b>harmony</b> and <b>balance</b> in one's life. As such, it is considered <b>lucky</b> in many Asian cultures. In fact, many people give bamboo as a house warming gift to bring <b>good health</b> to the recipient.
      </blockquote>

      <div class="s-docs">
        <h2 class="s-docs__title">Documentation</h2>

        <h3 class="s-docs__title">Installing</h3>

        <div class="s-docs__block">
          <div class="s-docs__right">
            <pre><code class="language-terminal">
              npm i @dkocsis-emarsys/bamboo
            </code></pre>
          </div>
        </div>

        <h3 class="s-docs__title">Attributes, properties and basic templating</h3>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Add <b>observedAttributes</b> getter to the component to listen on a list of attributes.</p>
            <blockquote class="s-docs__info">Properties are auto-magically created. If the attribute contains hyphen (-) then the property name will be in camelCase form, e.g.: <b>data-value</b> becomes <b>dataValue</b>.</blockquote>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get observedAttributes() {
                return ['value'];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Every component has built in state management and you can easily make a connection between properties and state by defining <b>boundProperties</b> getter.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get boundProperties() {
                return ['value'];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Templating has never been easier than it is now with Bamboo; just define a <b>template</b> getter on the component.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return html => html`
                  The value is: &lt;b&gt;${component._state.get('value')}&lt;/b&gt;
                `;
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">The component can add classes to itself with the <b>className</b> option. The parameter is a string and multiple classes can be append with a space between classes.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              super.init({
                className: 'my-example-1 my-example-1--dark'
              });
            </code></pre>
          </div>
        </div>

      </div>

      <hr>

      <div class="s-docs">
        <h3 class="s-docs__title">Advanced templating</h3>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">As you could see above a <b>simple template</b> looks like this.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return html => html`&lt;div&gt;Hello World!&lt;/div&gt;`;
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text"><b>Templates have various options</b>, so you can override almost everything related to rendering.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: templateFromFile,
                    container: document.createElement('div'),
                    autoAppend: true
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text"><b>Not all option needed.</b> You can create only the markup, then render it later anywhere you want.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: html`&lt;div&gt;Hello!&lt;/div&gt;`
                  }
                ];
              }

              ...

              // This gives back a method, what you have to call to get a documentFragment
              const helloTemplate = this._templater.render('hello');
              const fragment = helloTemplate();
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">You can check if the markup of a template exists. This is useful exspecially when you have <b>optional dynamic templates</b>.</p>
            <blockquote class="s-docs__info">With <b>this._templater.setMarkup(templateName:string, markup:any)</b> function you can change the markup of a template anytime.</blockquote>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: this.querySelector('[data-label]')
                  }
                ];
              }

              ...

              // Gives back true, if the markup has been set
              this._templater.hasMarkup('hello');
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text"><b>Multiple templates</b> could be defined by using an object in the template getter. You can set various options here.</p>
            <blockquote class="s-docs__info"><b>this._templater.parseHTML</b> can be used to easily create wrapper elements without using document.createElement and classList functions.</blockquote>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: html => html`&lt;div&gt;Hello&lt;/div&gt;`,
                    container: this._templater.parseHTML('&lt;div class="hello-container"&gt;&lt;/div&gt;'),
                    autoAppend: true
                  },
                  {
                    name: 'world',
                    markup: html => html`&lt;div&gt;World!&lt;/div&gt;`,
                    container: this._templater.parseHTML('&lt;div class="world-container"&gt;&lt;/div&gt;'),
                    autoAppend: true
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Templates can easily connect to eachother using the <b>_templater</b>'s render method.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: html => html`&lt;div&gt;Hello ${this._templater.render('world')}!&lt;/div&gt;`,
                    container: this._templater.parseHTML('&lt;div class="hello-container"&gt;&lt;/div&gt;'),
                    autoAppend: true
                  },
                  {
                    name: 'world',
                    markup: html => html`&lt;strong&gt;World&lt;/strong&gt;`
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">By default, templates are append to the component. It can be changed to <b>prepend</b> instead.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: html => html`&lt;div&gt;Hello&lt;/div&gt;`,
                    container: this._templater.parseHTML('&lt;div class="hello-container"&gt;&lt;/div&gt;'),
                    autoAppend: true,
                    prepend: true
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Another interesting and useful part of the templating system is the ability to <b>define templates in the DOM</b>. State variables can be used as well. In this case, be sure to <b>define a container</b> too.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-html">
              &lt;my-component&gt;
                &lt;template&gt;Hello ${value}!&lt;/template&gt;
              &lt;/my-component&gt;
            </code></pre>

            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: this.querySelector('template'),
                    container: document.createElement('div'),
                    autoAppend: true
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Markup option can be a <b>selector</b> too. This way your components can use the same template defined outside.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-html">
              &lt;template id="my-template"&gt;Hello ${value}!&lt;/template&gt;

              &lt;my-component&gt;&lt;/my-component&gt;
            </code></pre>

            <pre><code class="language-javascript">
              get template() {
                return [
                  {
                    name: 'hello',
                    markup: '#my-template'
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

      </div>

      <hr>

      <div class="s-docs">
        <h3 class="s-docs__title">Communication between parent and child</h3>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">First of all, in the parent component's constructor you have to set <b>listenChildren</b> option to <i>true</i>. It will prepares the parent to be able to receive events from children.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              super.init({
                listenChildren: true
              });
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">You have to do almost the same thing with the child component, except the option called <b>notifyParent</b>. This will make the component send events on <i>connect, disconnect and state changes</i>.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              super.init({
                notifyParent: true
              });
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">In the parent component, a new callback can be used for handling the events, <b>childrenChangedCallback</b>. This callback gives back the whole list of connected children. What you doing with this data is up to you. In this example we will use it to store the child's value from it's state.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              childrenChangedCallback(collection) {
                const childrenList = collection.get();

                const items = childrenList.map(child => {
                  this._state.set('childValue', child.state.value);
                });
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">A parent can have multiple different kind of children, and because of that the <b>collection</b> can give back them separately, if you want. Only thing you have to do is defining a <b>first parameter</b> with a tag name.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              const childrenList = collection.get('my-example-2-child');
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">If you don't want to notify the parent on every state change you can define it in the <b>boundProperties</b>. It's useful when the parent sets this value on the component, so it won't report back the change.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get boundProperties() {
                return [
                  {
                    name: 'value',
                    options: {
                      triggerCallback: false
                    }
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Another interesting option in the <b>boundProperties</b> is that you can tell the component to store the value with a different name in state.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get boundProperties() {
                return [
                  {
                    name: 'value',
                    as: 'stateValue'
                  }
                ];
              }
            </code></pre>
          </div>
        </div>

      </div>

      <hr>

      <div class="s-docs">
        <h3 class="s-docs__title">Event handling</h3>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Event handling is always something, what causing problems and makes our code much complex. With Bamboo, this problem becomes much less painful. You can define an <b>eventHandlers</b> getter.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get eventHandlers() {
                return {
                  ':click': '_onClick'
                }
              }

              _onClick(event) {
                // Do something here...
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Event handlers can be created through templates too using <b>data-handler</b> attribute and the event binding to the context.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get eventHandlers() {
                return {
                  'button:click': '_onButtonClick'
                }
              }

              get template() {
                return html => html`
                  &lt;button data-handler="button" onclick="${this}" &gt;Click Me!&lt;/button&gt;
                `;
              }

              _onButtonClick(event) {
                // Do something here...
              }
            </code></pre>
          </div>
        </div>

      </div>

      <hr>

      <div class="s-docs">
        <h3 class="s-docs__title">State mangement</h3>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Every component has it's own <b>state</b>.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.set('value', 1);         // Sets value on local state
              this._state.get('value');            // Gets value from local state
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">You can pass <b>options to the state</b> on set.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.set('value', 1, {
                triggerCallback: false,     // Won't call the attached callbacks
                triggerRender: false        // Won't call render function
              });
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">A transform function can be also passed as value. Perfect for incrementing/decrementing values.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.set('value', value => value + 2, { isTransformFunction: true });
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">With the awesome <b>subscription</b> system, you will always know, what's happening.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.subscribe('value', console.log);
              this._state.set('value', 1); // Logs '1, "value"'

              // Defining multiple at once with an array
              this._state.subscribe(['firstName', 'lastName'], console.log);
              this._state.set('firstName', 1); // Logs '1, "value"'
              this._state.set('lastName', 2); // Logs '2, lastName"'
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Every subscription comes with an <b>unsubscribe</b> method.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              const subscription = this._state.subscribe('value', console.log);
              this._state.set('value', 1); // Logs '1, "value"'
              subscription.unsubscribe();
              this._state.set('value', 1); // Logs nothing
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">It has the ability to <b>nest values</b>.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.set('group.value', 1);

              this._state.get('group.value');   // Gets 1
              this._state.get('group');         // Gets { value: 1 }
              this._state.get();                // Ultimately gets { group: { value: 1 } }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">State values can be formatted. Basically, there is two ways of defining it. You can use the <b>stateOptions</b> getter or calling the <b>setOptions()</b> function on state.<br>Transforming has some predefined options, these are <i>number, integer, float, boolean, json</i>. When using one of these, <b>transformFunction</b> won't be called.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get stateOptions() {
                return {
                  value: {
                    type: 'custom',
                    transformFunction: value => Number(value).toFixed(1)
                  }
                }
              }

              /* OR */

              this._state.setOptions('value', {
                type: 'custom',
                transformFunction: value => Number(value).toFixed(1)
              });
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">If you defined a default value for the state variable, you can access it with calling <b>getDefaultValue()</b> function.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._state.setOptions('value', {
                defaultValue: 1
              });

              ...

              this._state.getDefaultValue('value'); // Gets 1
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">State options can be defined through a static method too, called <b>stateOptions</b>.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              static get stateOptions() {
                return {
                  value: {
                    defaultValue: 'Default Value'
                  }
                };
              }
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text"><b>Global state</b> is available in every instance and work exactly like the default component state.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
              this._globalState.set('value', 1);  // Sets 1
              this._globalState.get('value');     // Gets 1
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text"><b>Prefixed global state</b> is useful, if you want to render only when a subset of state changed.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
                init() {
                  super.init({
                    watchGlobalState: 'subset' // or an array ['subset1, subset2']
                  });
                }

                ...

                this._globalState.set('subset.value');  // Triggers rendering in all component uses this prefix
            </code></pre>
          </div>
        </div>

        <div class="s-docs__block">
          <div class="s-docs__left">
            <p class="s-docs__text">Global state couldn't be true global, if you can't access it from anywhere. The whole object is available on the <b>window</b>.</p>
          </div>
          <div class="s-docs__right">
            <pre><code class="language-javascript">
                window.bamboo.globalState.value = 5; // Calls rendering of course
                window.bamboo.globalState.value; // 5
            </code></pre>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script src="./index.js"></script>
</body>
</html>
